
////
Referencia:
INTRODUÇÃO À LINGUAGEM C
Versão 2.0

INTRODUÇÃO A LINGUAGEM C
GACLI - CENTRO DE COMPUTAÇÃO - UNICAMP
http://www.fsc.ufsc.br/~canzian/root/tutorial-c-unicamp.pdf


10. Programação Estruturada (Modularização)
http://www.facom.ufu.br/~gustavo/IC/Programacao/Apostila_Algoritmos.pdf

EMENTA de Introdução a Programação:

Histórico das linguagens de programação. 
Descrição e construção de algoritmos. 
Metodologia de programação. 
Introdução a uma linguagem de programação moderna: 
	tipos elementares e compostos de dados; 
	operadores;
	expressões e funções; 
	mecanismos de passagem de parâmetros; 
	variáveis e comandos; 
	procedimentos; recursividade; 
	tipos definidos pelo programador e
	tipos abstratos de dados; 
	noções de estruturas dinâmicas de dados.
Aplicações práticas.

*  9184-0366
http://www.cprogressivo.net/2013/02/O-que-e-para-que-serve-e-como-usar-e-declarar-funcao-em-C.html

////

== Funções

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* Criar e usar funções e procedimentos em C
* Entender quando escrever uma função ou um procedimento
* Entender os diferentes tipos de passagem de parâmetro e quando utiliza-los
* Criar funções de ordem superior e homomorfismos
____________________

Quando elaboramos um algoritmo para resolver um problema, e quando 
escrevemos um programa para implementar este algoritmo, muitas vezes 
identificamos uma parte do algoritmo que deve ser realizada várias 
vezes para chegar ao resultado. Ou, ao trabalhar com vários algoritmos 
diferentes, identificamos algumas partes em comum entre eles. Nestes 
casos, é uma boa ideia isolar essas partes que se repetem de uma maneira 
que elas possam ser realizadas sem repetir o mesmo código várias vezes. 
Esse objetivo pode ser atingido com o uso de *funções* e *procedimentos*.

Neste capítulo vamos estudar as funções e procedimentos como uma forma 
de reaproveitar o código de tarefas que se repetem em um programa. Funções 
são importantes para a modularização de um programa, ou seja, para dividir
o programa em partes menores, cada parte com uma função específica; sem 
funções ou procedimentos um programa maior e mais complicado ficaria 
organizado em uma única parte que faz tudo e é mais difícil de entender. 
Neste capítulo vamos entender quando utilizar as funções ou procedimentos 
para melhor dividir o código dos nossos programas. 


[IMPORTANT]
====
Neste capítulo vamos *descartar a utilização de pseudocódigo*. Agora que você já
possui um conhecimento básico sobre a linguagem C e provavelmente escreveu alguns
programas nela, consideramos que não haverá mais necessidade de 
apresentar sintaxes para pseudocódigos. Portanto, neste capítulo em diante, o conteúdo 
apresentadao utilizará somente a sintaxe da linguagem C.
====



=== O que são funções

((Funções)) e ((procedimentos)) podem ser compreendidos como trechos reutilizáveis 
de código. Uma função ou procedimento pode, então, ser utilizado várias 
vezes por um mesmo programa. Isso simplifica a criação de programas maiores, 
dividindo-os em unidades menores que trabalham em conjunto. Funções e procedimentos 
são bastante semelhantes, e posteriormente vamos entender as diferenças entre eles.


[NOTE]
.Revisão
====
Lembre-se que durante o curso você já utilizou funções diversas vezes,
o que nós sabemos sobre funções até agora?

* Uma função implementa um comportamento que pode ser reutilizado;
* Para executar uma função, utilizamos o nome da função e passamos alguns 
parâmetros entre parênteses e separados por vírgula. Exemplo: `printf("R$ %1.2f", preco)`;
* A função `printf` é utilizada para imprimir texto na saída;
* As funções `scanf` e `getchar` para ler dados da entrada;
* As funções `strlen`, `strcpy`, `strcat` e `strchr` são utilizadas para 
manipular strings;
* As ((funções)) são agrupadas em ((módulos)). Exemplo: `stdio`;
====

Quando realizamos um processo com um determinado objetivo, é comum 
identificarmos partes que se repetem. Quando se trata de processos 
no mundo físico, muitas vezes criamos máquinas que ajudam a realizar 
as partes que se repetem. 

Por exemplo, pense no processo de limpar 
as roupas que usamos para podermos usá-las novamente. Este processo 
envolve lavar as roupas com água e sabão, secar as roupas lavadas e, 
finalmente, passar as roupas para evitar que fiquem amassadas. Para 
reduzir a quantidade de trabalho necessária para realizar esse processo,
foi inventada uma máquina de lavar, que realiza a lavagem das roupas. 
Uma pessoa que tem uma máquina de lavar pode usá-la repetidamente e, 
sempre que precisa de roupas limpas, precisa apenas se encarregar de 
enxugar e passar as roupas; a lavagem fica por conta da máquina. 
Dizemos inclusive que a *função* da máquina é lavar as roupas. 

As funções e os procedimentos funcionam desta forma, capturando 
partes menores de um algoritmo que podem ser utilizadas por 
outros algoritmos, economizando o trabalho de sempre refazer
uma determinada tarefa. 

==== Um exemplo

Vejamos um exemplo. Queremos criar um programa que calcule a média
final de um aluno em uma disciplina com três provas; o programa 
deve pedir ao usuário que entre com as notas das três provas, 
calcular a média aritmética das três notas e apresentar o resultado. 
O programador que resolveu o problema decidiu imprimir um separador 
na tela entre cada entrada de dados e o resultado final, desta forma
produzindo o seguinte código: 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_sem_proc.c[code/funcoes/media_sem_proc.c]

[source, c]
.Cálculo da média de um aluno em uma disciplina
----
include::code/funcoes/media_sem_proc.c[]
----
<1> Código que imprime um separador na tela. 

.Resultado da execução do programa
----
include::code/funcoes/media_sem_proc.out[]
----

É fácil de notar que o código usado para imprimir um separador se repete três 
vezes no programa. Podemos melhorar esse programa utilizando um procedimento 
que terá a tarefa de imprimir o separador. Isso teria o seguinte resultado:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_proc.c[code/funcoes/media_proc.c]

[source, c]
.Cálculo da média usando procedimento
----
include::code/funcoes/media_proc.c[]
----
<1> Definição do procedimento `imprime_separador`.
<2> Código no *corpo* do procedimento. 
<3> *Chamada* do procedimento `imprime_separador`.

A linha `void imprime_separador()` inicia a definição do procedimento 
chamado `imprime_separador`; o *corpo* do procedimento é o conjunto 
de comandos entre chaves que vem logo após o nome do procedimento. 
Os parênteses e a palavra `void` no início serão explicados depois. 
Dizemos que o uso de um procedimento é uma *chamada* ao mesmo. No 
exemplo anterior, o código do programa chama `imprime_separador` 
três vezes. 

É importante notar que além de economizar a repetição de linhas 
de código, o programa usando o procedimento `imprime_separador` também 
é mais fácil de entender porque transmite melhor as partes que 
compõem o programa. A melhor modularização do código do programa é
um motivo extremamente importante para usar funções e procedimentos, 
principalmente à medida que os programas se tornam maiores e 
mais complexos. 

=== Parâmetros

O exemplo usando `imprime_separador` é o caso mais simples, 
mas menos interessante do uso de procedimentos e funções, 
quando o código a ser reutilizado é sempre o mesmo. Na maioria 
das situações de interesse, queremos utilizar uma função ou 
procedimento em situações com algumas diferenças. Para tornar 
um procedimento (ou função) mais flexível, é preciso que 
informações sejam passadas para o procedimento. Isso é 
feito com o uso de *parâmetros*.

Já vimos muitas vezes o uso de procedimentos com parâmetros. 
Por exemplo, `printf` é um procedimento da biblioteca padrão 
da linguagem C que imprime a _string_ passada como parâmetro. 
Assim, 

[source, c]
----
printf("ola, mundo!");
----
é uma chamada ao procedimento `printf` com parâmetro `"ola, mundo!"`. 

Como exemplo do uso de parâmetros em um procedimento, voltemos ao 
exemplo do cálculo das médias. Vamos utilizar o separador para 
fazer uma visualização simples das notas e da média, imprimindo 
uma barra de tamanho proporcional a cada valor. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_param.c[code/funcoes/media_param.c]

[source, c]
.Uso de um procedimento com parâmetro
----
include::code/funcoes/media_param.c[]
----
<1> Definição do procedimento `imprime_separador`, com o parâmetro `nota`, do tipo `float`.
<2> Chamada do procedimento `imprime_separador`, passando o argumento `nota1`.

.Resultado da execução do programa code/funcoes/media_param.c
----
include::code/funcoes/media_param.out[]
----

Como se pode ver no resultado da execução do programa, o novo procedimento
`imprime_separador` imprime uma barra de tamanho proporcional à nota passada 
como argumento (são 5 caracteres `=` para cada ponto da nota). Note a 
diferença de nomenclatura: o procedimento `imprime_separador` é definido 
com um *((parâmetro))* de nome `nota`, mas é chamado com um *((argumento))*, 
o valor que é comunicado ao procedimento. No exemplo acima, `imprime_separador`
é chamado com os argumentos `nota`, `nota2`, `nota3` e `media`. É necessário 
especificar o tipo de cada parâmetro que deve ser passado para o procedimento; 
no caso, o parâmetro `nota` do procedimento `imprime_separador` é do tipo 
`float`. 

Na chamada de um procedimento com um parâmetro, o controle do programa 
executa o código do procedimento, atribuindo o valor passado como argumento 
à variável `nota` dentro do procedimento `imprime_separador`. Ou seja, o 
seguinte código 

[source, c]
----
int main() {
	float nota1; 

	printf("Entre a nota da primeira prova: ");
	scanf("%f", &nota1);

	imprime_separador(nota1);

	// resto do programa ...
}
----

funciona como se fosse o seguinte (utilizando o procedimento):

[source, c]
----
int main() {
	float nota1; 

	printf("Entre a nota da primeira prova: ");
	scanf("%f", &nota1);

	float nota = nota1;   // <1>
	int i;                // <2>
	printf("\n");
	for (i = 0; i < (int) lround(nota * 5.0); i++) {
		printf("=");
	}
	printf(" %3.2f / 10.0\n", nota);
	printf("\n");

	// resto do programa ...
}
----
<1> Atribuição do valor do argumento `nota1` para o parâmetro `nota`.
<2> Resto do corpo do procedimento `imprime_separador`. 

Este exemplo é apenas uma ilustração; na prática o chamado do procedimento 
não funciona exatamente desta forma. Em particular, a variável `nota`, que 
designa o parâmetro do procedimento, só existe enquanto o procedimento 
executa. Isso será detalhado mais tarde. 

O uso de parâmetros nos procedimentos os tornam muito mais flexíveis para 
uso em diferentes situações. Mas assim como é útil que o código que chama 
o procedimento comunique informações para o procedimento chamado, muitas 
vezes também é útil que o procedimento comunique algo de volta para o 
código que o chamou; neste caso passamos dos procedimentos para as funções. 

=== Retorno de Valores com Funções

Até agora só temos usado procedimentos como ferramenta de modularização do 
código, mas muitas vezes é útil chamar um procedimento que retorna alguma 
informação de volta para o código que o chamou. Esta é a diferença entre 
procedimentos e funções: as funções retornam algum valor. Desta forma, as 
funções em linguagem C são similares às funções da matemática: uma função 
como 

[latexmath]
+++++
\[
f: \mathbb{Z} \rightarrow \mathbb{Z},\quad f(x) = x^2 + 2
\]
+++++


tem um parâmetro x (um inteiro), e retorna um determinado valor que depende do
parâmetro passado; por exemplo, 

[latexmath]
+++++
\[
f(5) = 5^2 + 2 = 27
\]
+++++


É fácil escrever a mesma função em linguagem C:

[source, c]
----
int f(int x) {         // <1>
	return x * x + 2;  // <2>
}
----
<1> Definição da função `f`. A definição começa com `int f(...)`, significando 
que o tipo de retorno da função é `int`.
<2> A palavra-chave `return` determina o valor de retorno da função `f`, que será 
o resultado da expressão `x * x + 2`.

A função `f` do exemplo faz o mesmo que a versão matemática: dado o valor do parâmetro 
`x`, retorna um valor que é igual a `x` ao quadrado, somado a dois. Note que é preciso 
especificar o tipo do valor que é retornado pela função, e por isso toda função começa 
com o tipo de retorno antes do nome. Especificar os tipos dos parâmetros e o tipo do 
valor de retorno também é similar às funções na matemática, para as quais devemos 
especificar os conjuntos domínio e contra-domínio. 

==== Funções, Procedimentos e o Tipo `void`

Neste ponto pode surgir uma pergunta: se é preciso especificar o tipo do valor 
retornado por uma função antes do nome da função (por exemplo `int f(...)`), 
por que nos procedimentos usa-se a palavra-chave `void`? 

A verdade é que, embora algumas linguagens de programação façam uma distinção 
entre procedimentos e funções, na linguagem C existem apenas funções. Como a 
diferença entre procedimentos e funções é apenas o fato de retornar ou não 
um valor, os procedimentos em C são considerados funções que retornam um valor 
_vazio_. É isso que significa o `void` no início da definição de um procedimento 
como `imprime_separador`, que vimos anteriormente; a rigor, `imprime_separador` 
é uma função, mas retorna um valor _vazio_, ou seja, nenhum valor. O tipo `void` 
na linguagem C é um tipo especial que denota a ausência de valores. 

Como procedimentos em C são funções, também é possível usar `return` em 
procedimentos, mas apenas para terminar a execução do procedimento e retornar 
imediatamente. Isso às vezes é útil para terminar um procedimento em pontos 
diferentes do seu final. Também pode-se utilizar `return` ao final do 
procedimento, mas este uso é supérfluo e não é recomendado. 

O seguinte exemplo demonstra o uso do `return` em procedimentos. Continuando 
no tema relacionado ao cálculo de médias, queremos detectar se uma das notas 
entradas pelo usuário é uma nota inválida antes de fazer o cálculo da média. 
Neste caso o programa deve apenas imprimir se algum valor negativo foi 
entrado pelo usuário. O procedimento `possui_negativo` será responsável por 
imprimir uma mensagem caso um dos valores seja negativo. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/retorno_proc.c[code/funcoes/retorno_proc.c]

[source, c]
.Uso de `return` em um procedimento
----
include::code/funcoes/retorno_proc.c[]
----
<1> Uso do `return` para sair prematuramente do procedimento. 
<2> Este comando de impressão será executado se nenhuma das 
condições testadas em `possui_negativo` for verdade, ou seja, 
se nenhum dos valores dos parâmetros for negativo. 

.Resultado de duas execuções do programa code/funcoes/retorno_proc.c
----
include::code/funcoes/retorno_proc.out[]
----

O procedimento `possui_negativo` deve verificar se um dos três números passados 
como argumentos, mas basta achar um número entre eles para que o resultado possa 
ser impresso imediatamente, e o procedimento pode retornar; por isso usamos 
`return` assim que o primeiro valor negativo seja encontrado. 

Esse exemplo ainda tem um problema: como pode ser visto nos exemplos de execução, 
mesmo que o usuário entre um valor negativo, a média aritmética das três notas 
ainda é impressa na tela (o usuário apenas é avisado que um dos valores foi negativo).
Isso é uma indicação que seria melhor que `possui_negativo` fosse uma função, e que o 
programa principal verificasse o valor retornado e tomasse uma decisão. Se fizermos 
essas alterações ficamos com o seguinte programa:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/retorno_func.c[code/funcoes/retorno_func.c]

[source, c]
.Reescrevendo o exemplo anterior para usar uma função
----
include::code/funcoes/retorno_func.c[]
----
<1> A função `possui_negativo` agora retorna um inteiro de valor 1 caso um dos 
valores dos parâmetros seja negativo, e 0 caso contrário (todos são positivos).
<2> Teste para identificar se uma ou mais dos parâmetros informados são negativos.
<3> A função retorna `1` se um dos números passados para a função for negativo. 
<4> Caso nenhum dos números seja negativo, o controle passa para o comando `return`
ao final da função e o valor `0` é retornado para indicar que nenhum número negativo 
foi encontrado. 
<5> O programa principal verifica o valor de retorno da função `possui_negativo` e
imprime informações adequadas na tela para cada caso. 

.Resultado de duas execuções do programa code/funcoes/retorno_func.c
----
include::code/funcoes/retorno_func.out[]
----

Como pode-se ver nos dois exemplos de execução do programa, a saída agora é mais 
adequada. Caso uma das notas informadas seja negativa, o programa não imprime um 
valor de média, apenas avisando o usuário do erro na entrada de dados. O código 
da função `possui_negativo` também foi simplificado pelo uso do operador lógico 
OU. 

Como funções e procedimentos são tratados de maneira uniforme na linguagem C 
(e em muitas outras linguagens atuais), a partir de agora vamos usar o termo 
*função* tanto para funções como para procedimentos. Isso não deve gerar nenhuma 
confusão. Em caso de dúvida, basta olhar para a definição da função no código-fonte 
do programa; se a função for declarada com tipo de retorno `void`, então é um 
procedimento. 

=== Um Exemplo Matemático: Equação de Segundo Grau

Nesta seção veremos mais um exemplo do uso de funções, em um programa 
para calcular as raízes de uma equação de segundo grau. Neste exemplo 
as funções não serão utilizadas várias vezes, mas o programa principal 
será mais claro e mais fácil de entender graças à melhor modularização 
conseguida com o uso das funções. 

Lembremos que um _polinômio de segundo grau_ é uma soma de três termos 
em potências de uma variável, por exemplo

[latexmath]
++++
\[
   P(x) = ax^2 + bx + c
\]
++++

onde latexmath:[$a$], latexmath:[$b$] e latexmath:[$c$] são coeficientes 
constantes. Uma _equação de segundo grau_ é formada ao igualar um polinômio 
de segundo grau a zero, ou seja

[latexmath]
++++
\[
   ax^2 + bx + c = 0
\]
++++

Sabemos que uma equação de segundo grau pode ter até duas *raízes* reais; cada 
raiz é um valor da variável latexmath:[$x$] que satisfaz a equação. Essas raízes 
podem ser encontradas pela chamada _fórmula de Bhaskara_. A fórmula consiste 
em calcular um valor auxiliar chamado de latexmath:[$\Delta$] (_delta_), e 
usar o valor calculado para identificar quantas raízes reais distintas podem 
ser encontradas para a equação: 

* se latexmath:[$\Delta < 0$], a equação não tem raízes reais;
* se latexmath:[$\Delta = 0$], a equação possui uma raiz real;
* se latexmath:[$\Delta > 0$], a equação possui duas raízes reais distintas. 

A fórmula para calcular latexmath:[$\Delta$] é

[latexmath]
++++
\[
   \Delta = b^2 - 4 a c
\]
++++

No caso latexmath:[$\Delta >= 0$], as raízes da equação são dadas por

[latexmath]
++++
\[
   x = \frac{-b \pm \sqrt{\Delta}}{2a}
\]
++++

uma das raízes sendo obtida pelo uso do sinal positivo em 
latexmath:[$-b \pm \sqrt{\Delta}$], enquanto que a outra raiz é calculada pelo 
uso do sinal negativo. Se [$\Delta = 0$], ambos os valores serão iguais. 

Como exemplo do uso da fórmula de Bhaskara, considere a equação:

[latexmath]
++++
\[
x^2 - 5x + 6 = 0
\]
++++

Nesta equação os coeficientes são latexmath:[$a=1, b=-5$] e latexmath:[$c=6$]. 
Calculamos o latexmath:[$\Delta$] usando os valores dos coeficientes:

[latexmath]
++++
\[
\Delta = b^2 - 4ac = (-5)^2 - 4 \times 1 \times 6 = 25 - 24 = 1
\]
++++

E assim podemos calcular as raízes:

[latexmath]
++++
\[
   x = \frac{-b \pm \sqrt{\Delta}}{2a} = \frac{5 \pm \sqrt{1}}{2} = \frac{5 \pm 1}{2}
\]
++++

Ou seja, as raízes são latexmath:[$6/2 = 3$] e latexmath:[$4/2 = 2$]. 

Agora vamos escrever um programa que resolve equações do segundo grau, usando o 
processo mostrado acima. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/equacao.c[code/funcoes/equacao.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/equacao.c[]
----
<1> Função que calcula o valor do latexmath:[$\Delta$].
<2> Função que calcula a raiz positiva da equação. 
<3> Função que calcula a raiz negativa da equação. 

.Resultado de três execuções do programa code/funcoes/equacao.c
----
include::code/funcoes/equacao.out[]
----

Podemos ver neste exemplo funções para calcular o valor do latexmath:[$\Delta$] e 
das duas raízes da equação. O programa obtém o valor do latexmath:[$\Delta$] e 
verifica se a equação tem nenhuma, uma ou duas raízes, e imprime o resultado 
de acordo com isso. Embora cada função seja usada apenas uma vez, o programa 
principal é mais claro e mais fácil de entender porque cada função faz uma 
parte do processo necessário, ao invés de ter todo o código junto na função `main`. 
Funções são importantes não só para reutilizar código e diminuir esforço de 
programação, mas também para melhorar a modularização do programa e torná-lo mais 
fácil de ser lido. Em situações práticas, muitas vezes é necessário ler código 
que já foi produzido antes e entendê-lo, seja para consertar defeitos encontrados 
ou para extender suas funcionalidades. Tornar um programa mais legível auxilia e 
reduz o custo relacionado à _manutenção_ do mesmo. 

Entretanto, este último exemplo pode parecer estranho do ponto de vista da 
modularização, já que duas de suas funções são quase idênticas. As funções que 
calculam o valor das raízes, `raiz_positiva` e `raiz_negativa`, mudam apenas em 
uma operação. Podemos pensar em como reescrever o programa para usar apenas uma 
função ao invés de duas funções quase idênticas. A repetição desnecessária 
de código pode ser um problema para a manutenção de um programa. 

A chave para criar uma só função que calcula os dois valores é criar um novo 
parâmetro que indica qual das duas raízes deve ser calculada. Vamos usar um 
parâmetro chamado `sinal` que indica, pelo seu valor, se será usada uma soma ou 
subtração no cálculo da raiz. Se `sinal` for 1, será usada uma soma, e se for 
`-1` será usada uma subtração. O código resultante é mais compacto e evita 
repetições:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/equacao2.c[code/funcoes/equacao2.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/equacao2.c[]
----

Esse processo, de criar um primeiro programa que resolve o problema desejado, mas 
depois revisar o código para torná-lo mais claro, mais legível e mais fácil de manter, 
é muito importante na programação de computadores, e normalmente recebe o nome de 
*refatoração*. 

=== Escopo de Variáveis 

Quando trabalhamos com programas compostos por várias funções, nos deparamos com 
questões relativas à _visibilidade_ das variáveis em diferentes partes do programa. 


=== Passagem de Parâmetros 
texto.

==== Por Valor
texto.

==== Por Referência
texto.

=== Protótipos e Declaração de Funções
Lorem ipsum. 

=== Reunindo tudo
texto.

=== Criando funções para reutilizar código

Até agora os programas que escrevemos continham apenas a função `main`, e todo
nosso código era escrito dentro dela.


////
http://www.slideshare.net/MMSequeira/semana-2-6479012
-- funções não devem ter efeito colaterais
--- escrever no teclado

função sem parâmetro
função com parametros
função com retorno

////


////
Passing Arguments
Methods of Passing Arguments
Passing by Value
Passing by Address

Using Return Values and Prototypes
Returning Values
The Return Data Type
One Last Step: Prototype
Wrapping Things Up
Funções recursivas

////
