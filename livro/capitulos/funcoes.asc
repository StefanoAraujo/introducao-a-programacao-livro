
== Funções

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* Criar e usar funções e procedimentos em C
* Entender quando escrever uma função ou um procedimento
* Entender as regras de escopo para variáveis em C
* Entender os diferentes tipos de passagem de parâmetro e quando utiliza-los
____________________

Quando elaboramos um algoritmo para resolver um problema, e quando 
escrevemos um programa para implementar este algoritmo, muitas vezes 
identificamos uma parte do algoritmo que deve ser realizada várias 
vezes para chegar ao resultado. Ou, ao trabalhar com vários algoritmos 
diferentes, identificamos algumas partes em comum entre eles. Nestes 
casos, é uma boa ideia isolar essas partes que se repetem de uma maneira 
que elas possam ser realizadas sem repetir o mesmo código várias vezes. 
Esse objetivo pode ser atingido com o uso de *funções* e *procedimentos*.

Neste capítulo vamos estudar as funções e procedimentos como uma forma 
de reaproveitar o código de tarefas que se repetem em um programa. Funções 
são importantes para a modularização de um programa, ou seja, para dividir
o programa em partes menores, cada parte com uma função específica; sem 
funções ou procedimentos um programa maior e mais complicado ficaria 
organizado em uma única parte que faz tudo e é mais difícil de entender. 
Neste capítulo vamos entender quando utilizar as funções ou procedimentos 
para melhor dividir o código dos nossos programas. 


[IMPORTANT]
====
Neste capítulo vamos *descartar a utilização de pseudocódigo*. Agora que você já
possui um conhecimento básico sobre a linguagem C e provavelmente escreveu alguns
programas nela, consideramos que não haverá mais necessidade de 
apresentar sintaxes para pseudocódigos. Portanto, neste capítulo em diante, o conteúdo 
apresentadao utilizará somente a sintaxe da linguagem C.
====



=== O que são funções

((Funções)) e ((procedimentos)) podem ser compreendidos como trechos reutilizáveis 
de código. Uma função ou procedimento pode, então, ser utilizado várias 
vezes por um mesmo programa. Isso simplifica a criação de programas maiores, 
dividindo-os em unidades menores que trabalham em conjunto. Funções e procedimentos 
são bastante semelhantes, e posteriormente vamos entender as diferenças entre eles.


[NOTE]
.Revisão
====
Lembre-se que durante o curso você já utilizou funções diversas vezes,
o que nós sabemos sobre funções até agora?

* Uma função implementa um comportamento que pode ser reutilizado;
* Para executar uma função, utilizamos o nome da função e passamos alguns 
parâmetros entre parênteses e separados por vírgula. Exemplo: `printf("R$ %1.2f", preco)`;
* A função `printf` é utilizada para imprimir texto na saída;
* As funções `scanf` e `getchar` para ler dados da entrada;
* As funções `strlen`, `strcpy`, `strcat` e `strchr` são utilizadas para 
manipular strings;
* As ((funções)) são agrupadas em ((módulos)). Exemplo: `stdio`;
====

Quando realizamos um processo com um determinado objetivo, é comum 
identificarmos partes que se repetem. Quando se trata de processos 
no mundo físico, muitas vezes criamos máquinas que ajudam a realizar 
as partes que se repetem. 

Por exemplo, pense no processo de limpar 
as roupas que usamos para podermos usá-las novamente. Este processo 
envolve lavar as roupas com água e sabão, secar as roupas lavadas e, 
finalmente, passar as roupas para evitar que fiquem amassadas. Para 
reduzir a quantidade de trabalho necessária para realizar esse processo,
foi inventada uma máquina de lavar, que realiza a lavagem das roupas. 
Uma pessoa que tem uma máquina de lavar pode usá-la repetidamente e, 
sempre que precisa de roupas limpas, precisa apenas se encarregar de 
enxugar e passar as roupas; a lavagem fica por conta da máquina. 
Dizemos inclusive que a *função* da máquina é lavar as roupas. 

As funções e os procedimentos funcionam desta forma, capturando 
partes menores de um algoritmo que podem ser utilizadas por 
outros algoritmos, economizando o trabalho de sempre refazer
uma determinada tarefa. 

==== Um exemplo

Vejamos um exemplo. Queremos criar um programa que calcule a média
final de um aluno em uma disciplina com três provas; o programa 
deve pedir ao usuário que entre com as notas das três provas, 
calcular a média aritmética das três notas e apresentar o resultado. 
O programador que resolveu o problema decidiu imprimir um separador 
na tela entre cada entrada de dados e o resultado final, desta forma
produzindo o seguinte código: 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_sem_proc.c[code/funcoes/media_sem_proc.c]

[source, c]
.Cálculo da média de um aluno em uma disciplina
----
include::code/funcoes/media_sem_proc.c[]
----
<1> Código que imprime um separador na tela. 

.Resultado da execução do programa
----
include::code/funcoes/media_sem_proc.out[]
----

É fácil de notar que o código usado para imprimir um separador se repete três 
vezes no programa. Podemos melhorar esse programa utilizando um procedimento 
que terá a tarefa de imprimir o separador. Isso teria o seguinte resultado:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_proc.c[code/funcoes/media_proc.c]

[source, c]
.Cálculo da média usando procedimento
----
include::code/funcoes/media_proc.c[]
----
<1> Definição do procedimento `imprime_separador`.
<2> Código no *corpo* do procedimento. 
<3> *Chamada* do procedimento `imprime_separador`.

A linha `void imprime_separador()` inicia a definição do procedimento 
chamado `imprime_separador`; o *corpo* do procedimento é o conjunto 
de comandos entre chaves que vem logo após o nome do procedimento. 
Os parênteses e a palavra `void` no início serão explicados depois. 
Dizemos que o uso de um procedimento é uma *chamada* ao mesmo. No 
exemplo anterior, o código do programa chama `imprime_separador` 
três vezes. 

É importante notar que além de economizar a repetição de linhas 
de código, o programa usando o procedimento `imprime_separador` também 
é mais fácil de entender porque transmite melhor as partes que 
compõem o programa. A melhor modularização do código do programa é
um motivo extremamente importante para usar funções e procedimentos, 
principalmente à medida que os programas se tornam maiores e 
mais complexos. 

=== Parâmetros

O exemplo usando `imprime_separador` é o caso mais simples, 
mas menos interessante do uso de procedimentos e funções, 
quando o código a ser reutilizado é sempre o mesmo. Na maioria 
das situações de interesse, queremos utilizar uma função ou 
procedimento em situações com algumas diferenças. Para tornar 
um procedimento (ou função) mais flexível, é preciso que 
informações sejam passadas para o procedimento. Isso é 
feito com o uso de *parâmetros*.

Já vimos muitas vezes o uso de procedimentos com parâmetros. 
Por exemplo, `printf` é um procedimento da biblioteca padrão 
da linguagem C que imprime a _string_ passada como parâmetro. 
Assim, 

[source, c]
----
printf("ola, mundo!");
----
é uma chamada ao procedimento `printf` com parâmetro `"ola, mundo!"`. 

Como exemplo do uso de parâmetros em um procedimento, voltemos ao 
exemplo do cálculo das médias. Vamos utilizar o separador para 
fazer uma visualização simples das notas e da média, imprimindo 
uma barra de tamanho proporcional a cada valor. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_param.c[code/funcoes/media_param.c]

[source, c]
.Uso de um procedimento com parâmetro
----
include::code/funcoes/media_param.c[]
----
<1> Definição do procedimento `imprime_separador`, com o parâmetro `nota`, do tipo `float`.
<2> Chamada do procedimento `imprime_separador`, passando o argumento `nota1`.

.Resultado da execução do programa code/funcoes/media_param.c
----
include::code/funcoes/media_param.out[]
----

Como se pode ver no resultado da execução do programa, o novo procedimento
`imprime_separador` imprime uma barra de tamanho proporcional à nota passada 
como argumento (são 5 caracteres `=` para cada ponto da nota). Note a 
diferença de nomenclatura: o procedimento `imprime_separador` é definido 
com um *((parâmetro))* de nome `nota`, mas é chamado com um *((argumento))*, 
o valor que é comunicado ao procedimento. No exemplo acima, `imprime_separador`
é chamado com os argumentos `nota`, `nota2`, `nota3` e `media`. É necessário 
especificar o tipo de cada parâmetro que deve ser passado para o procedimento; 
no caso, o parâmetro `nota` do procedimento `imprime_separador` é do tipo 
`float`. 

Na chamada de um procedimento com um parâmetro, o controle do programa 
executa o código do procedimento, atribuindo o valor passado como argumento 
à variável `nota` dentro do procedimento `imprime_separador`. Ou seja, o 
seguinte código 

[source, c]
----
int main() {
	float nota1; 

	printf("Entre a nota da primeira prova: ");
	scanf("%f", &nota1);

	imprime_separador(nota1);

	// resto do programa ...
}
----

funciona como se fosse o seguinte (utilizando o procedimento):

[source, c]
----
int main() {
	float nota1; 

	printf("Entre a nota da primeira prova: ");
	scanf("%f", &nota1);

	float nota = nota1;   // <1>
	int i;                // <2>
	printf("\n");
	for (i = 0; i < (int) lround(nota * 5.0); i++) {
		printf("=");
	}
	printf(" %3.2f / 10.0\n", nota);
	printf("\n");

	// resto do programa ...
}
----
<1> Atribuição do valor do argumento `nota1` para o parâmetro `nota`.
<2> Resto do corpo do procedimento `imprime_separador`. 

Este exemplo é apenas uma ilustração; na prática o chamado do procedimento 
não funciona exatamente desta forma. Em particular, a variável `nota`, que 
designa o parâmetro do procedimento, só existe enquanto o procedimento 
executa. Isso será detalhado mais tarde. 

O uso de parâmetros nos procedimentos os tornam muito mais flexíveis para 
uso em diferentes situações. Mas assim como é útil que o código que chama 
o procedimento comunique informações para o procedimento chamado, muitas 
vezes também é útil que o procedimento comunique algo de volta para o 
código que o chamou; neste caso passamos dos procedimentos para as funções. 

=== Retorno de Valores com Funções

Até agora só temos usado procedimentos como ferramenta de modularização do 
código, mas muitas vezes é útil chamar um procedimento que retorna alguma 
informação de volta para o código que o chamou. Esta é a diferença entre 
procedimentos e funções: as funções retornam algum valor. Desta forma, as 
funções em linguagem C são similares às funções da matemática: uma função 
como 

[latexmath]
+++++
\[
f: \mathbb{Z} \rightarrow \mathbb{Z},\quad f(x) = x^2 + 2
\]
+++++


tem um parâmetro x (um inteiro), e retorna um determinado valor que depende do
parâmetro passado; por exemplo, 

[latexmath]
+++++
\[
f(5) = 5^2 + 2 = 27
\]
+++++


É fácil escrever a mesma função em linguagem C:

[source, c]
----
int f(int x) {         // <1>
	return x * x + 2;  // <2>
}
----
<1> Definição da função `f`. A definição começa com `int f(...)`, significando 
que o tipo de retorno da função é `int`.
<2> A palavra-chave `return` determina o valor de retorno da função `f`, que será 
o resultado da expressão `x * x + 2`.

A função `f` do exemplo faz o mesmo que a versão matemática: dado o valor do parâmetro 
`x`, retorna um valor que é igual a `x` ao quadrado, somado a dois. Note que é preciso 
especificar o tipo do valor que é retornado pela função, e por isso toda função começa 
com o tipo de retorno antes do nome. Especificar os tipos dos parâmetros e o tipo do 
valor de retorno também é similar às funções na matemática, para as quais devemos 
especificar os conjuntos domínio e contra-domínio. 

==== Funções, Procedimentos e o Tipo `void`

Neste ponto pode surgir uma pergunta: se é preciso especificar o tipo do valor 
retornado por uma função antes do nome da função (por exemplo `int f(...)`), 
por que nos procedimentos usa-se a palavra-chave `void`? 

A verdade é que, embora algumas linguagens de programação façam uma distinção 
entre procedimentos e funções, na linguagem C existem apenas funções. Como a 
diferença entre procedimentos e funções é apenas o fato de retornar ou não 
um valor, os procedimentos em C são considerados funções que retornam um valor 
_vazio_. É isso que significa o `void` no início da definição de um procedimento 
como `imprime_separador`, que vimos anteriormente; a rigor, `imprime_separador` 
é uma função, mas retorna um valor _vazio_, ou seja, nenhum valor. O tipo `void` 
na linguagem C é um tipo especial que denota a ausência de valores. 

Como procedimentos em C são funções, também é possível usar `return` em 
procedimentos, mas apenas para terminar a execução do procedimento e retornar 
imediatamente. Isso às vezes é útil para terminar um procedimento em pontos 
diferentes do seu final. Também pode-se utilizar `return` ao final do 
procedimento, mas este uso é supérfluo e não é recomendado. 

O seguinte exemplo demonstra o uso do `return` em procedimentos. Continuando 
no tema relacionado ao cálculo de médias, queremos detectar se uma das notas 
entradas pelo usuário é uma nota inválida antes de fazer o cálculo da média. 
Neste caso o programa deve apenas imprimir se algum valor negativo foi 
entrado pelo usuário. O procedimento `possui_negativo` será responsável por 
imprimir uma mensagem caso um dos valores seja negativo. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/retorno_proc.c[code/funcoes/retorno_proc.c]

[source, c]
.Uso de `return` em um procedimento
----
include::code/funcoes/retorno_proc.c[]
----
<1> Uso do `return` para sair prematuramente do procedimento. 
<2> Este comando de impressão será executado se nenhuma das 
condições testadas em `possui_negativo` for verdade, ou seja, 
se nenhum dos valores dos parâmetros for negativo. 

.Resultado de duas execuções do programa code/funcoes/retorno_proc.c
----
include::code/funcoes/retorno_proc.out[]
----

O procedimento `possui_negativo` deve verificar se um dos três números passados 
como argumentos, mas basta achar um número entre eles para que o resultado possa 
ser impresso imediatamente, e o procedimento pode retornar; por isso usamos 
`return` assim que o primeiro valor negativo seja encontrado. 

Esse exemplo ainda tem um problema: como pode ser visto nos exemplos de execução, 
mesmo que o usuário entre um valor negativo, a média aritmética das três notas 
ainda é impressa na tela (o usuário apenas é avisado que um dos valores foi negativo).
Isso é uma indicação que seria melhor que `possui_negativo` fosse uma função, e que o 
programa principal verificasse o valor retornado e tomasse uma decisão. Se fizermos 
essas alterações ficamos com o seguinte programa:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/retorno_func.c[code/funcoes/retorno_func.c]

[source, c]
.Reescrevendo o exemplo anterior para usar uma função
----
include::code/funcoes/retorno_func.c[]
----
<1> A função `possui_negativo` agora retorna um inteiro de valor 1 caso um dos 
valores dos parâmetros seja negativo, e 0 caso contrário (todos são positivos).
<2> Teste para identificar se uma ou mais dos parâmetros informados são negativos.
<3> A função retorna `1` se um dos números passados para a função for negativo. 
<4> Caso nenhum dos números seja negativo, o controle passa para o comando `return`
ao final da função e o valor `0` é retornado para indicar que nenhum número negativo 
foi encontrado. 
<5> O programa principal verifica o valor de retorno da função `possui_negativo` e
imprime informações adequadas na tela para cada caso. 

.Resultado de duas execuções do programa code/funcoes/retorno_func.c
----
include::code/funcoes/retorno_func.out[]
----

Como pode-se ver nos dois exemplos de execução do programa, a saída agora é mais 
adequada. Caso uma das notas informadas seja negativa, o programa não imprime um 
valor de média, apenas avisando o usuário do erro na entrada de dados. O código 
da função `possui_negativo` também foi simplificado pelo uso do operador lógico 
OU. 

Como funções e procedimentos são tratados de maneira uniforme na linguagem C 
(e em muitas outras linguagens atuais), a partir de agora vamos usar o termo 
*função* tanto para funções como para procedimentos. Isso não deve gerar nenhuma 
confusão. Em caso de dúvida, basta olhar para a definição da função no código-fonte 
do programa; se a função for declarada com tipo de retorno `void`, então é um 
procedimento. 

=== Um Exemplo Matemático: Equação de Segundo Grau

Nesta seção veremos mais um exemplo do uso de funções, em um programa 
para calcular as raízes de uma equação de segundo grau. Neste exemplo 
as funções não serão utilizadas várias vezes, mas o programa principal 
será mais claro e mais fácil de entender graças à melhor modularização 
conseguida com o uso das funções. 

Lembremos que um _polinômio de segundo grau_ é uma soma de três termos 
em potências de uma variável, por exemplo

[latexmath]
++++
\[
   P(x) = ax^2 + bx + c
\]
++++

onde latexmath:[$a$], latexmath:[$b$] e latexmath:[$c$] são coeficientes 
constantes. Uma _equação de segundo grau_ é formada ao igualar um polinômio 
de segundo grau a zero, ou seja

[latexmath]
++++
\[
   ax^2 + bx + c = 0
\]
++++

Sabemos que uma equação de segundo grau pode ter até duas *raízes* reais; cada 
raiz é um valor da variável latexmath:[$x$] que satisfaz a equação. Essas raízes 
podem ser encontradas pela chamada _fórmula de Bhaskara_. A fórmula consiste 
em calcular um valor auxiliar chamado de latexmath:[$\Delta$] (_delta_), e 
usar o valor calculado para identificar quantas raízes reais distintas podem 
ser encontradas para a equação: 

* se latexmath:[$\Delta < 0$], a equação não tem raízes reais;
* se latexmath:[$\Delta = 0$], a equação possui uma raiz real;
* se latexmath:[$\Delta > 0$], a equação possui duas raízes reais distintas. 

A fórmula para calcular latexmath:[$\Delta$] é

[latexmath]
++++
\[
   \Delta = b^2 - 4 a c
\]
++++

No caso latexmath:[$\Delta >= 0$], as raízes da equação são dadas por

[latexmath]
++++
\[
   x = \frac{-b \pm \sqrt{\Delta}}{2a}
\]
++++

uma das raízes sendo obtida pelo uso do sinal positivo em 
latexmath:[$-b \pm \sqrt{\Delta}$], enquanto que a outra raiz é calculada pelo 
uso do sinal negativo. Se [$\Delta = 0$], ambos os valores serão iguais. 

Como exemplo do uso da fórmula de Bhaskara, considere a equação:

[latexmath]
++++
\[
x^2 - 5x + 6 = 0
\]
++++

Nesta equação os coeficientes são latexmath:[$a=1, b=-5$] e latexmath:[$c=6$]. 
Calculamos o latexmath:[$\Delta$] usando os valores dos coeficientes:

[latexmath]
++++
\[
\Delta = b^2 - 4ac = (-5)^2 - 4 \times 1 \times 6 = 25 - 24 = 1
\]
++++

E assim podemos calcular as raízes:

[latexmath]
++++
\[
   x = \frac{-b \pm \sqrt{\Delta}}{2a} = \frac{5 \pm \sqrt{1}}{2} = \frac{5 \pm 1}{2}
\]
++++

Ou seja, as raízes são latexmath:[$6/2 = 3$] e latexmath:[$4/2 = 2$]. 

Agora vamos escrever um programa que resolve equações do segundo grau, usando o 
processo mostrado acima. 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/equacao.c[code/funcoes/equacao.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/equacao.c[]
----
<1> Função que calcula o valor do latexmath:[$\Delta$].
<2> Função que calcula a raiz positiva da equação. 
<3> Função que calcula a raiz negativa da equação. 

.Resultado de três execuções do programa code/funcoes/equacao.c
----
include::code/funcoes/equacao.out[]
----

Podemos ver neste exemplo funções para calcular o valor do latexmath:[$\Delta$] e 
das duas raízes da equação. O programa obtém o valor do latexmath:[$\Delta$] e 
verifica se a equação tem nenhuma, uma ou duas raízes, e imprime o resultado 
de acordo com isso. Embora cada função seja usada apenas uma vez, o programa 
principal é mais claro e mais fácil de entender porque cada função faz uma 
parte do processo necessário, ao invés de ter todo o código junto na função `main`. 
Funções são importantes não só para reutilizar código e diminuir esforço de 
programação, mas também para melhorar a modularização do programa e torná-lo mais 
fácil de ser lido. Em situações práticas, muitas vezes é necessário ler código 
que já foi produzido antes e entendê-lo, seja para consertar defeitos encontrados 
ou para extender suas funcionalidades. Tornar um programa mais legível auxilia e 
reduz o custo relacionado à _manutenção_ do mesmo. 

Entretanto, este último exemplo pode parecer estranho do ponto de vista da 
modularização, já que duas de suas funções são quase idênticas. As funções que 
calculam o valor das raízes, `raiz_positiva` e `raiz_negativa`, mudam apenas em 
uma operação. Podemos pensar em como reescrever o programa para usar apenas uma 
função ao invés de duas funções quase idênticas. A repetição desnecessária 
de código pode ser um problema para a manutenção de um programa. 

A chave para criar uma só função que calcula os dois valores é criar um novo 
parâmetro que indica qual das duas raízes deve ser calculada. Vamos usar um 
parâmetro chamado `sinal` que indica, pelo seu valor, se será usada uma soma ou 
subtração no cálculo da raiz. Se `sinal` for 1, será usada uma soma, e se for 
`-1` será usada uma subtração. O código resultante é mais compacto e evita 
repetições:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/equacao2.c[code/funcoes/equacao2.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/equacao2.c[]
----

É comum quando escrevemos programas se concentrar, inicialmente, em fazê-lo 
funcionar, ou seja, resolver o problema desejado. Entretanto, é importante 
depois reler o código e escrito e revisá-lo para torná-lo mais claro, mais 
legível e mais fácil de manter. Esse processo de revisar o código de um programa
sem mudar sua funcionalidade é muito importante na programação de computadores, 
e normalmente recebe o nome de *refatoração*. 

=== Escopo de Variáveis 

Quando trabalhamos com programas compostos por várias funções, nos deparamos com 
questões relativas à _visibilidade_ das variáveis em diferentes partes do programa. 
Ou seja, se uma variável é visível ou acessível em certas partes de um programa. 

Um programador iniciante poderia escrever o seguinte programa para calcular a 
média aritmética de três notas:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_erro.c[code/funcoes/media_erro.c]

[source, c]
.Cálculo da média usando código incorreto
----
include::code/funcoes/media_erro.c[]
----
<1> Esta linha contém erros e o programa não será compilado. 

O raciocínio do programador é "se as variáveis `nota1`, `nota2` e `nota3` existem na 
função `main` e a função `calc_media` é chamada dentro de `main`, as variáveis 
`nota1`, `nota2` e `nota3` não deveriam ser visíveis dentro de `calc_media` ?"

Acontece que isso não é válido na linguagem C, e qualquer compilador da linguagem 
vai acusar erros de compilação neste programa, avisando que as variáveis `nota1`, 
`nota2` e `nota3` não foram declaradas. 

Para entender como funciona a visibilidade das variáveis em um programa na linguagem 
C, precisamos falar sobre as regras de *escopo* desta linguagem. O ((escopo)) de 
uma variável é a parte do programa na qual ela é visível e pode ser acessada. 

A linguagem C usa um conjunto de regras de escopo que recebe o nome de _escopo estático_ 
ou _escopo léxico_. Essas regras são bastante simples de entender e aplicar, 
como veremos a seguir. 

Em programas na linguagem C existem dois tipos de escopo (regiões de visibilidade):

* escopo global;
* escopos locais. 

Existe apenas um escopo global e, como indicado pelo seu nome, ele contém elementos 
que são visíveis em todo o programa. Já os escopos locais são vários e particulares: 
basicamente, cada função define um escopo local que corresponde com o _corpo_ da 
função. 

Desta forma, variáveis declaradas no escopo global (ou seja, "fora" de qualquer 
função) são visíveis em todo programa, enquanto variáveis declaradas dentro de 
uma função são visíveis apenas dentro da mesma função. No exemplo anterior, as 
variáveis `nota1`, `nota2` e `nota3` são visíveis apenas dentro da função `main`, 
e por isso não podem ser acessadas dentro da função `calc_media`. 

Isso pode ser resolvido mudando as variáveis `nota1`, `nota2` e `nota3` para 
o escopo global, ou seja, tornando-as _variáveis globais_, como no seguinte 
programa:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_globais.c[code/funcoes/media_globais.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/media_globais.c[]
----
<1> Declaração das variáveis `nota1`, `nota2` e `nota3` como variáveis globais. 
Note que elas estão declaradas "fora" de qualquer função. 
<2> Código dentro de `calc_media` que usa as variáveis globais. Neste programa 
as variáveis estão visíveis e não ocorrerá um erro durante a compilação. 
<3> Código dentro de `main` que usa as variáveis globais. Variáveis globais 
são visíveis em todo o programa, incluindo na função principal. 

Este programa agora compila corretamente e funciona para o cálculo da média. 
Mas é importante observar que esse tipo de prática _não é recomendada_. 
Entre as boas práticas da programação está a sugestão de usar variáveis 
globais apenas quando absolutamente necessário. Como variáveis globais 
podem ser acessadas e ter seu valor alterado por qualquer parte do 
programa, fica difícil saber que partes podem influenciar ou serem 
influenciadas pelas variáveis globais, o que torna todo o programa 
mais difícil de entender. Para o exemplo das notas, é melhor e mais 
de acordo com boas práticas de programação comunicar as notas para 
a função `calc_media` usando parâmtros, como segue: 

Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/media_param2.c[code/funcoes/media_param2.c]

[source, c]
.Cálculo de raízes de uma equação de segundo grau
----
include::code/funcoes/media_param2.c[]
----

Este código funciona corretamente e evita o uso desnecessário de 
variáveis globais. 

==== Escopo dos Parâmetros

Uma pergunta que pode surgir (especialmente após o exemplo anterior) 
é "qual o escopo dos parâmetros das funções?" A resposta é simples: 
para questões de visibilidade, o escopo dos parâmetros das funções é 
o escopo local da função da qual eles pertencem. Ou seja, os parâmetros 
de uma função funcionam exatamente como variáveis locais declaradas 
dentro da função. 

==== Sombreamento e Sobreposição de Escopos

O que acontece se duas variáveis tiverem o mesmo nome em um só 
programa? A resposta depende de onde as variáveis em questão 
são declaradas. 

Não podem existir duas variáveis de mesmo nome em um mesmo escopo; 
um programa que tente declarar duas variáveis de mesmo nome no mesmo 
escopo ocasionará um erro quando for compilado. Assim, não podem 
existir duas variáveis globais de nome `x` ou duas variáveis de nome 
`y` em uma mesma função. 

Em escopos diferentes a regra muda: variáveis de mesmo nome podem 
existir em um programa se forem declarados em escopos distintos. 
Isso é bastante útil: imagine um programa com 20 ou 30 mil linhas 
de código (o que hoje em dia é considerado um programa de _pequeno_ 
a _médio_ porte); um programa deste tamanho precisa usar um grande 
número de variáveis, se cada uma delas precisasse ter um nome 
diferente de todas as outras, seria muito difícil dar nomes a vários
milhares de variáveis. Imagine que um programa deste tamanho pode 
ter mais de mil laços `for`, cada um com uma variável de controle, e 
cada uma dessas variáveis teria que ter um nome diferente. Por isso, 
as regras de escopo também são úteis para estabelecer espaços locais
onde os nomes não entram em conflitos com os nomes de outros 
escopos locais. 

Quando temos duas variáveis de mesmo nome em diferentes escopos locais, 
ou seja, duas funções diferentes, o resultado é 
simples, já que essas variáveis de mesmo nome nunca seriam visíveis 
no mesmo local do programa. Mas e se tivermos duas variáveis de mesmo 
nome, sendo uma variável local e uma global? Neste caso, dentro da 
função que declara a variável com mesmo nome da global, existirão 
duas variáveis que poderiam ser visíveis com o mesmo nome. O que 
acontece nesses casos é chamado de *sombreamento*: a variável do 
escopo local _esconde_ a variável do escopo global. Vamos ilustrar 
essa regra com um exemplo: 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/sombra.c[code/funcoes/sombra.c]

[source, c]
.Exemplo de sombreamento de variáveis globais
----
include::code/funcoes/sombra.c[]
----
<1> Declaração da variável global `x`.
<2> Declaração da variável local `x` na função `f`.
<3> Declaração da variável local `y` na função `f`.
<4> Declaração da variável local `y` na função `g`.

Vemos no exemplo que existe uma variável global chamada `x` e uma 
variável local `x` na função `f`. A função `f` também tem 
uma variável local chamada `y`, e há uma variável local de mesmo 
nome na função `g`. As variáveis chamadas `y` em `f` e `g` não 
interferem, pois são escopos totalmente diferentes. 

Já as variáveis chamadas `x` interferem, já que uma está no escopo 
global e outra está no escopo local da função `f`. A questão é: o que 
é impresso pelo programa? Isso depende dos valores de `x` dentro da 
função `f` e na função `g` (que usa `x` para calcular o valor de `y`, que 
é retornado). A execução do programa imprime o seguinte:

.Resultado da execução do programa code/funcoes/sombra.c
----
include::code/funcoes/sombra.out[]
----

A primeira linha é o que é impresso na função `f`. Como existe uma 
variável local `x` declarada em `f`, dentro da função `f` a variável 
`x` tem o valor 60, como declarado; o valor de `y` calculado em 
`f` é, então, latexmath:[$60 \times 60 = 3600$]. Já na função `g` 
não existe uma variável `x` local, então o valor de `x` dentro de `g` 
é o valor da variável global `x`, que é igual a 5; desta forma, `y` em 
`g` tem valor latexmath:[$5 \times 5 = 25$]. Isso explica a saída do 
programa como visto acima. 

[NOTE]
====
Uma consequência da regra de sombreamento é que dentro de funções que 
tenham variáveis locais que escondem variáveis globais de mesmo nome, 
é impossível acessar ou utilizar as variáveis globais escondidas. No 
exemplo anterior, dentro da função `f` é impossível ter acesso à 
variável global `x`. 
====

=== Passagem de Parâmetros 

Com o que vimos até agora sobre parâmetros de funções, eles funcionam 
de maneira simples: o código que chama uma função especifica expressões 
para cada um dos argumentos da função. Os valores de cada expressão são 
calculados e transmitidos como o valor dos parâmetros declarados na 
função. 

Entretanto, isso não é suficiente para todos os casos em que podemos 
querer usar parâmetros. Por exemplo, digamos que temos uma situação 
em que é necessário trocar o valor de duas variáveis, e que isso é 
necessário várias vezes ao longo do programa. Para evitar repetição, 
a melhor solução é escrever uma função que realiza a troca o valor 
de duas variáveis. O exemplo a seguir mostra o que acontece quando 
tentamos fazer isso apenas com o que vimos até agora: 

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/troca.c[code/funcoes/troca.c]

[source, c]
.Tentativa de trocar o valor de duas variáveis usando uma função
----
include::code/funcoes/troca.c[]
----

.Resultado da execução do programa code/funcoes/troca.c
----
include::code/funcoes/troca.out[]
----

Como se vê no resultado da execução do programa, embora as variáveis 
`a` e `b` realmente troquem de valor dentro da função `troca_variaveis`, 
isso não afeta o valor das variáveis `x` e `y` em `main`. Isso acontece 
porque, normalmente, os parâmetros em C são passados *por valor*, ou seja, 
apenas o valor de `x` e `y` são copiados para `a` e `b`. Precisamos que 
as variáveis na função `troca_variaveis` de alguma maneira afetem as variáveis 
que foram usadas como parâmetro, e para isso é necessário usar o modo de 
passagem de parâmetros chamado de passagem *por referência*. A seguir, vamos 
ver em maiores detalhes como funcionam esses dois modos de passagem de 
parâmetros. 

==== Passagem Por Valor

A passagem de parâmetros por valor é a situação padrão na linguagem C. 
Este modo de passagem de parâmetros comunica apenas valores entre 
o código chamador e a função chamada. 

A passagem por valor funciona da seguinte forma: para uma função `f` 
com N parâmetros, uma chamada de `f` deve conter N expressões como 
argumentos (se o número de argumentos não corresponder ao número 
de parâmetros declarados, o compilador acusará um erro no programa). 
Então o seguinte processo de chamada de função acontece:

1. O valor de cada uma das N expressões usadas como argumento é calculado
e guardado;
2. N variáveis locais são criadas para a função chamada, uma para cada 
parâmetro da função, e usando o nome declarado na função; 
3. Os valores calculados no passo 1 são atribuídos às variáveis criadas 
no passo 2. 
4. O corpo da função `f` é executado. 

Como as variáveis criadas para os parâmetros são locais, elas deixam 
de existir quando a função chamada termina, e isso não tem nenhum efeito 
nas expressões que foram usadas para atribuir valor aos parâmetros ao início 
da função. Isso significa que o programa para troca de valor de variáveis 
mostrado acima funciona de maneira similar ao seguinte programa (no qual 
colocamos o código da função `troca_variaveis` diretamente na função `main`):

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/troca_main.c[code/funcoes/troca_main.c]

[source, c]
.Tentativa de trocar o valor de duas variáveis usando uma função
----
include::code/funcoes/troca_main.c[]
----

Neste caso fica claro que as variáveis `x` e `y` são usadas apenas para obter
o valor inicial das variáveis `a` e `b`, e portanto a mudança de valor das 
duas últimas não deve afetar `x` e `y`. 

A passagem de parâmetros por valor é simples e funciona bem na maioria dos 
casos. Mas em algumas situações pode ser desejável ter uma forma de afetar 
variáveis externas à uma determinada função, e para isso se usa a passagem de 
parâmetros por referência. 

==== Passagem Por Referência

A passagem de parâmetros por referência funciona passando para a função chamada 
_referências_ para variáveis ao invés de valores de expressões. Isso permite à 
função chamada afetar as variáveis usadas como argumento para a função. 

Vamos ilustrar como isso funciona demonstrando como criar uma função que troca 
o valor de duas variáveis e realmente funciona:

.Código fonte
{gitrepo}/blob/master/livro/capitulos/code/funcoes/troca_ref.c[code/funcoes/troca_ref.c]

[source, c]
.Tentativa de trocar o valor de duas variáveis usando uma função
----
include::code/funcoes/troca_ref.c[]
----

.Resultado da execução do programa code/funcoes/troca_ref.c
----
include::code/funcoes/troca_ref.out[]
----

=== Protótipos e Declaração de Funções

Lorem ipsum. 

=== Recapitulando

Neste capítulo vimos uma importante ferramenta para a criação de programas 
na linguagem C: funções. As funções (e os procedimentos, que são tratados na linguagem C 
como funções) possibilitam a reutilização de trechos de código em várias partes 
de um programa, e permitem isolar determinadas componentes do programa em unidades 
mais auto-contidas, melhorando a modularização do programa. É raro que um programa 
não-trivial na linguagem C não faça uso de funções. Vimos exemplos do uso de procedimentos 
(funções que não retornam valores) com e sem parâmetros. Vimos também como usar parâmetros para 
funções e como retornar valores a partir de uma função. As regras que regem a visibilidade 
de variáveis locais, globais e parâmetros de funções foram apresentadas, assim como os 
diferentes modos de passagem de parâmetros e como utilizá-los: passagem por valor e por 
referência. Compreender o conteúdo deste capítulo é extremamente importante para 
aprender a programar bem na linguagem C. 

